Χρίστος Ιωάννου
Α.Μ: 1115201900222

------------------------------------------------------------------------------------------------------------------------

Execution instructions:

$ make ALL
$ ./sniffer [-p path]

------------------------------------------------------------------------------------------------------------------------

-----------------------------
|    Γενικές Σημειώσεις:    |
-----------------------------
- Αν δοθεί παράμετρος [-p path] τότε πρέπει το path να υπάρχει προτού εκτελεστεί το πρόγραμμα - δε δημιουργείται.
- Μέσα στο .tar.gz παραδίδω επίσης 2 άδειους (αλλά απαραίτητους) φακέλους με ονομασίες "named_pipes" και "out" στους
οποίους θα περιέχονται τα named pipes και τα .out files που δημιουργούνται αντίστοιχα, καθώς δεν κάνω αυτή τη δουλειά
σε κάποιο αρχείο πηγαίου κώδικα.
- Το κάθε named pipe που δημιουργείται στον φάκελο "named_pipes" φέρει το όνομα της διεργασίας που το έφτιαξε.

-----------------------------
|        sniffer.cpp        |
-----------------------------
Στην αρχή του προγράμματος δημιουργείται ένα sigaction "act" με handler "cleanup" και flag "SA_RESTART" έτσι ώστε όταν
ο Manager/Sniffer λάβει σήμα SIGCHLD από worker, να ξεμπλοκάρει από την κλήση read που κάνει στο κανάλι επικοινωνίας με
τον Listener, να μπορεί να ανανεώσει την πληροφορία του για διαθέσιμους worker και να επαναλάβει το read. Αρχικοποιείται
και γεμίζει το signal set και έπειτα ανιχνεύονται σήματα SIGCHLD και SIGINT. Στον signal handler "cleanup" γίνεται
έλεγχος αν το σήμα που λήφθηκε είναι SIGINT ώστε πριν τερματιστεί ο manager να σκοτώσει όλες τις υπόλοιπες διεργασίες
και να γίνει το απαραίτητο cleanup αρχείων / pipes / named_pipes κλπ. Γι'αυτό λοιπόν, κλείνει το read & write του pipe
μεταξύ Manager - Listener (αν δεν είναι ήδη κλειστά), στέλνεται σήμα SIGKILL στη διεργασία Listener, SIGCONT
ακολουθούμενο από SIGINT σε όλες τις άλλες διεργασίες και τέλος SIGKILL στον ίδιο τον Manager ώστε να τερματίσει. Η
χρήση του σήματος SIGCONT γίνεται ώστε να "ξεμπλοκάρουν" τυχόν Workers που είναι σε κατάσταση "stopped" και να μπορούν
να πάρουν το σήμα SIGINT που ακολουθάει ώστε να κάνουν το δικό τους cleanup.

Έπειτα, γίνεται έλεγχος των ορισμάτων εκτέλεσης του προγράμματος και παίρνουμε το δοσμένο path (διαφορετικά τον τρέχον
κατάλογο). Δημιουργείται το pipe για επικοινωνία μεταξύ Manager - Listener και η διεργασία Listener μέσω fork(). Στον
Manager κλείνει το write αφού διαβάζει μόνο ενώ στον Listener κλείνει το read. Επίσης, συνδέεται η έξοδος της διεργασίας
Listener με το pipe με την κλήση του dup2 και τέλος εκτελείται η inotifywait χρησιμοποιώντας execlp με τις κατάλληλες
παραμέτρους (το "σώμα" της διεργασίας Listener αντικαθίσταται με αυτό της inotifywait).

Στη συνέχεια, υπάρχει ένα infinite loop (while (1)) μέσα στο οποίο διαβάζονται συνεχώς αρχεία που ανιχνεύει και γράφει ο
Listener στο pipe και αναθέτονται σε κάποιο worker (αν υπάρχει διαθέσιμος) διαφορετικά δημιουργείται καινούργιος, για να
γίνει η λειτουργία που αναφέρεται στην εκφώνηση. Μέσω ενός άλλου while διαβάζεται από το pipe ένας - ένας χαρακτήρας /
byte και μπαίνει στον "mybuffer" ο οποίος είναι ένα vector από chars. Όταν ανιχνευθεί αλλαγή γραμμής '\n' τότε
διασχίζονται τα περιεχόμενα του buffer ένα - ένα και ελέγχεται η ύπαρξη του "CREATE" ή "MOVED_TO" ώστε να εξαχθεί το
filename. Καθαρίζει ο buffer βγαίνουμε από το (2ο) while loop και προσθέτεται '\n' στο τέλος του filename ώστε να
ξέρουμε που τελειώνει.

Σε αυτό το σημείο, παίρνουμε τους worker που άλλαξαν κατάσταση (έγιναν "stopped", ο Manager παίρνει το σήμα SIGCHLD) με
waitpid() και μπαίνουν στην ουρά "workers_queue" (η ουρά αυτή κρατάει PIDs διεργασιών Workers). Μετά, γίνεται έλεγχος αν
υπάρχουν διαθέσιμοι workers (έλεγχος αν η ουρά δεν είναι άδεια). Αν ναι, τότε βγάζουμε τον πρώτο worker της ουράς καθώς
θα του αναθέσουμε το αρχείο filename που πήραμε προηγουμένως. Ανοίγει το named pipe του (που κανονικά πρέπει να
δημιουργήθηκε πριν) για Read & Write, γράφεται μέσα το όνομα του αρχείου ("filename") και στέλνεται σήμα SIGCONT από τον
Manager στον Worker για να συνεχίσει / "ξεμπλοκάρει". Σε διαφορετική περίπτωση (δεν υπάρχει διαθέσιμος worker), πρέπει
να δημιουργηθεί καινούργιος μέσω fork(). Για case 0 (worker) δημιουργείται καινούργιο named pipe με όνομα τον αριθμό της
διεργασίας, ανοίγει το named pipe για Read & Write, γράφεται το όνομα του αρχείου ("filename") μέσα στο named pipe που
δημιουργήθηκε και γίνεται κλήση της execlp δίνοντας ως παράμετρο (argument στο worker.cpp) το path που γίνεται monitor.
Ο Manager δεν κάνει τίποτα, πάει στην αρχή της λούπας while(1).

-----------------------------
|        worker.cpp         |
-----------------------------
Όπως και στον Manager, έτσι και στον Worker υπάρχει ένα sigaction "act" και ανιχνεύεται σήμα SIGINT που στέλνει ο
Manager ώστε να γίνει το απαραίτητο cleanup στον signal handler:
    1) Κλείνει το Named Pipe
    2) Κλείνει το Read και Write αρχείο αν είναι ανοικτά
    3) Η διεργασία Worker τερματίζει τον εαυτό της με raise(SIGKILL)

Αρχικά, ανοίγει το Named Pipe και παίρνουμε το file descriptor του. Έπειτα, ακολουθάει η ίδια λογική που έχουμε και στον
Manager. Μέσα σε ένα infinite loop (while(1)) γίνεται όλη η λειτουργία του Worker. Πάλι, διαβάζεται ένας - ένας
χαρακτήρας / byte βάζοντας τον στον buffer έως ότου ανιχνευθεί αλλαγή γραμμής (εξού και η προσθήκη του '\n' στο τέλος
του "filename" προηγουμένως). Διασχίζοντας στη συνέχεια τα περιεχόμενα του buffer, φτιάχνουμε κατάλληλα τα strings που
κρατάνε το όνομα του αρχείου απ' όπου θα διαβάσουμε και το όνομα του αρχείου το οποίο θα δημιουργήσουμε και θα γράψουμε
τα locations με τον αριθμό εμφάνισης τους. Υπενθυμίζω ότι θεωρώ πως τα output files θα γράφονται όλα στον φάκελο "out"
τον συμπεριλαμβάνω στο .tar.gz οπότε το "write_file" κρατάει κάτι της μορφής "out/<filename>.out".

Ακολούθως, ανοίγει το αρχείο για διάβασμα, παίρνουμε το file descriptor του και διαβάζεται ένας - ένας χαρακτήρας,
μπαίνοντας στον buffer - έως ότου βρεθεί αλλαγή γραμμής ('\n'). Τότε, διασχίζονται τα περιεχόμενα του "mybuffer" μέχρι
να βρεθεί το "http://" - αν βρεθεί, τότε οτιδήποτε υπάρχει στον "mybuffer" μετά το "http://" μπαίνει σε έναν άλλον
buffer "url" εκτός και αν ανιχνευτεί '/' ή '\0' ή '\n' ή ' ' που αντιπροσωπεύουν το τέλος του location. Σε αυτή την
περίπτωση, διασχίζουμε τα περιεχόμενα του buffer "url" (όχι του "mybuffer") και τα βάζουμε σε ένα string "loc",
αφαιρώντας το 'www.' στην αρχή (αν υπάρχει). Αφού επιτέλους πάρουμε το "loc", ελέγχουμε αν υπάρχει μέσα στο map με όνομα
"locations". Αν ναι, τότε αυξάνεται ο μετρητής κατά ένα, διαφορετικά εισάγεται ως νέο κλειδί με τιμή 1.

Τέλος, με ένα traverse του map "locations", γράφεται όλη η απαραίτητη πληροφορία στο output αρχείο, αδειάζει το map,
κλείνουν τα αρχεία και η διεργασία Worker στέλνει σήμα SIGSTOP στον εαυτό της για να τεθεί σε κατάσταση "stopped". Όταν
λάβει σήμα SIGCONT από τον Manager θα επαναλάβει όλη τη διαδικασία που βρίσκεται εντός του while(1) loop.

-----------------------------
|        finder.sh          |
-----------------------------
Εκτελείται με:
    ./finder.sh <list_of_tlds>

Ο αριθμός των ορισμάτων αποθηκεύεται σε μία μεταβλητή 'argc' ενώ τα ονόματα των αρχείων που βρίσκονται μέσα στον φάκελο
'out/' στο 'files', παίρνοντάς τα ως αποτέλεσμα του command 'ls out'. Διασχίζεται ένα - ένα το κάθε όρισμα/TLD και
φτιάχνεται κατάλληλα (πριν ξεκινήσει υπάρχει τελεία '.' και αφότου τελειώσει υπάρχει κενό ' '). Ο μετρητής 'count'
μηδενίζεται στην αρχή της αναζήτησης κάθε διαφορετικού TLD. Σε κάθε αρχείο (που πήραμε προηγουμένως με 'ls out'),
αναθέτουμε στο "match" το αποτέλεσμα της εντολής 'grep' με [pattern] το περιεχόμενο του tld ("$tld") και [file] το
τωρινό αρχείο στο οποίο αναζητούμε, με το path από τον τρέχον κατάλογο προς αυτό ("out/$file"). Με άλλα λόγια, το
"match" κρατάει όλες τις γραμμές του δοσμένου αρχείου οι οποίες περιέχουν το pattern/tld. Τέλος, διασχίζονται τα
περιεχόμενα του "match" και εάν κάποιο από αυτά είναι ακέραιος τότε προστίθεται στον μετρητή 'count'. Ο έλεγχος για το
αν είναι κάποιο στοιχείο ακέραιος, γίνεται με τη χρήση Regular Expression (=~). Το '^' σηματοδοτεί την αρχή του string
και το '$' το τέλος, ενώ το '+' σημαίνει μπορεί να έχει κιάλλα ίδια από τα προηγούμενα. Άρα, με αυτό τον τρόπο του λέμε
να περιέχει μόνο ψηφία (και κατ'επέκταση να είναι ακέραιος).
